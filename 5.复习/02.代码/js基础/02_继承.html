<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>


  <script>
   /* 
   如何区分一个函数是不是构造函数?
    解:根据他的使用方法来判断
  使用构造函数和ES6的类设计并测试以下需要
    需求1: 
      现在2个人, 都有姓名与年龄(值自己指定), 都能自我介绍自己的姓名和年龄, 能得到当前的总人数
    需求2: 
      现在又有了一个学生, 它有身价的属性, 能介绍它的所有信息
      又有一个老师, 它有教授课程的属性, 能介绍它的所有信息
  */
    // function Person(name,age){
    //   this.name=name;
    //   this.age=age;
    //   Person.prototype.count++;
    //   // this.sayHello = function(){
    //   //   console.log(`我叫${this.name},我今年${this.age}岁`)
    //   // }
    // }
    // Person.prototype.count = 0;


    // let p1 = new Person('xiaoming',23);
    // let p2 = new Person('xiaowang',18);


    // Person.prototype.sayHello = function(){
    //     console.log(`我叫${this.name},我今年${this.age}岁`)
    // }
    // // function person(name,age){
    // //   this.name=name;
    // //   this.age=age;
    // // }
    // // window.Person();
    // // new person();

    //   p1.sayHello();
    //   p2.sayHello();
    //   // console.log(p1.sayHello===p2.sayHello,p1.count)


    //   /*
    //     构造函数继承(组合继承)
    //       1.将父类的实例对象作为子类的原型对象使用
    //       2.子类借调父类,生成实例对象
    //       3.重写方法

    //   */
    //   function Student(name,age,price){
    //     // 经过这一步,父类实例对象所具有的所有属性,子类实例都有
    //     Person.call(this,name,age);
    //     this.price=price;
    //   }
    // //   Student.prototype.sayHello=function(){
    // //     console.log(`我叫${this.name},我今年${this.age}岁,我有${this.price}元钱`)
    // // }

    // Student.prototype = new Person();
    // Student.prototype.constructor = Student;
    // Student.prototype.sayHello=function(){
    //     console.log(`我叫${this.name},我今年${this.age}岁,我有${this.price}元钱`)
    // }

    // var s1 = new Student('钱小明',19,100000000);

    // // 查找顺序:s1自身没有->s1.__proto__(new Person())也没有
    // // ->s1.__proto__.__proto__(Person.prototype)
    // s1.sayHello();
    // console.log(s1)


    // 属性用等号赋值,就会放在实例对象上,如果是方法的简写,就放在原型对象上
    class Person{
      constructor(name,age){
        this.name=name;
        this.age=age;
      }

      // this.count=0
      count = 0

      // Person.prototype.sayHello=function(){.....}
      static sayHello(){
        console.log(`我叫${this.name},我今年${this.age}岁`)
      }
      
      // sayHello = function(){
      //   console.log(`我叫${this.name},我今年${this.age}岁`)
      // }
    }

    let p1 =new Person("xiaoming",23);
    console.log(p1,Person.sayHello)

    class Student extends Person{
      constructor(name,age,price){
        // Person.call(this,name,age)
        // super即是对象又是函数
        // super对象代表着构造函数本身
        // super函数代表的是借调父类
        super(name,age);
        this.price=price;
        super.sayHello();
      }

      static sayHello(){
        console.log(`我叫${this.name},我今年${this.age}岁,我有${this.price}元钱`)
      }

    }

    let s1 = new Student("xiaohong",26,10)

  </script>
  
</body>
</html>